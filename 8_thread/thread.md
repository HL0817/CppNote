# C++多线程编程

*本文主要围绕 C++11 及以后的版本，讨论新支持的多线程和同步机制*

## 目录
+ [CPU中的进程和线程](#CPU中的进程和线程)
    + [CPU工作原理](#CPU工作原理)
    + [进程和线程](#进程和线程)
+ [多线程](#多线程)
    + [std::thread](#std::thread)
    + [std::jthread](#std::jthread)
+ [同步机制](#同步机制)
    + [互斥量与锁](#互斥量与锁)
        + [std::mutex](#std::mutex)
        + [Generic mutex management](#generic-mutex-management)
    + [条件变量](#条件变量)
    + [信号量](#信号量)
    + [线程屏障](#线程屏障)
        + [std::latch](#std::latch)
        + [std::barrier](#std::barrier)

## CPU中的进程和线程
*简单介绍 CPU、核心、进程、线程四者的关系*
### CPU工作原理
先上个CPU工作原理图，结合图示来讲讲CPU是怎么进行工作的：

![CPU工作原理](./images/CPU工作原理.png)
+ 代码段被翻译为一条条指令，被CPU的控制单元接受用来执行；
+ 数据段被存储单元读取，用以提供数据给控制单元或运算单元进行具体的操作；
+ 指令执行完成后的结果被写回存储单元，然后由存储单元写回数据段。

### CPU架构
认识一下常见的几种CPU架构：
#### 单核CPU
![单核CPU](./images/单核CPU.jpg)
+ 单核CPU只有一个核心CORE；
+ CPU内部有多个cache，就是俗称的多级缓存（L1、L2、L3三级缓存），越靠近CORE的缓存空间越小，但读写速度越快；
+ MMU，Memory Management Unit内存管理单元，是CPU访问内存、读写数据的管理单元。

#### 多核CPU
![多核CPU](./images/多核CPU.jpg)
+ 多核CPU，顾名思义是有两个及以上核心数量的CPU；
+ 对于CPU本身而言，它拥有一个MMU和一个L3 cache，被多个核心共享，不同核心通过L3 cache共享和同步数据；
+ 对于核心而言，它独立拥有一个L1 cache和一个L2 cache，用来进行自身的指令执行和数据读写。

#### 多CPU
![多CPU](./images/多CPU.jpg)
+ 多CPU中关于核心的内容，基本和单CPU一致，不过多赘述；
+ 因为有多个CPU，所有每个CPU有独立的MMU和L3 cache，因此CPU间通信主要依靠内存，他们本身不能直接通信。

### 进程和线程
*老生常谈的解释：进程是资源分配的基本单位，线程是CPU调度的基本单位。这个定义相信计算机相关从业人员都听过，但是过于抽象。本节将会结合笔者对CPU的理解对进程和线程进行分析和解释。*
#### 进程
##### 动态
程序在执行时，会在内存中分配空间来管理代码（指令）和资源（堆栈、读取的文件等），而这些在内存中临时的、动态生成的资源集合被称为进程。进程是程序的执行过程，动态产生和消亡。
##### 并发
不同进程在CPU中是并发执行，所有进程被CPU轮询调度。
*被 CPU 轮流切换执行叫并发；被 CPU 同时执行叫并行。*
##### 独立
进程是某个程序的执行过程，那么相对于其他进程而言，这个进程是独立的、不受其他进程影响的。
*经典说法：进程崩溃不会影响到其他进程。这就是进程独立的体现。*

#### CPU中的进程
具体看下CPU是如何并发的执行不同进程的。

![进程并发](./images/进程并发.jpg)
+ 执行某个进程的时间段被称为CPU时间片；
+ CPU时间片不断切换，表示CPU在不断的轮询调度不同的进程；
+ 图中的进程A、B、C的不断切换凸显了进程的并发和独立。

#### 线程
*世界上本没有线程，但嫌弃CPU切换进程太慢的人多了，也就有了线程。*
##### 线程的出现
原本CPU调度的最基本单位是进程，但是因为要并发不同进程，每次都要重新从内存中读取进程的上下文，这个操作比较耗时。于是就有了线程的出现，帮助我们缩短切换的时间。

![线程并发](./images/线程并发.jpg)
+ 这里把进程并发转换成了线程并发，就CPU的执行而言，时间不增不减；
+ 变化点：
    + 进程切换会有CPU访问内存保存和卸载当前进程的上下文，装载下一个进程的上下文；
    + 线程切换由CPU访问内部cache切换线程的上下文。
+ CPU内部的读写操作总是比CPU去读写内存要快上很多，这一部分时间就被节约了下来。

##### 并行线程
CPU由单核心阶段性的进化到了多核心

### 特别的CPU架构
这里扩展一下其他类型的CPU架构。
需要说明的是，笔者是基于一个CPU只能在一个CPU时间片内执行一个进程，一个核心只能执行一个线程的朴素观念对前文CPU中的进程和线程进行理解的。但是随着技术发展，已经有了以下介绍的更新更高级的CPU架构，但对于我们理解进程和线程的工作是没有太大影响的。
##### 双核4线程
![双核4线程](./images/单CPU双核4线程.jpg)
+ 每个核心可以并行的执行两个线程；
+ 据说每个核心拥有自己单独的MMU，那么理论上来说每个核心就可以执行单独的进程，进程开始并行执行；
+ 这样看上去更像多CPU架构了，每个核心相当于单独的CPU。

## 多线程

### std::thread

### std::jthread

## 同步机制

### 互斥量与锁
#### std::mutex
#### Generic mutex management

### 条件变量

### 信号量

### 线程屏障
#### std::latch
#### std::barrier
